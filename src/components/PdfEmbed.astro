---
interface Props {
    src: string;
    alt?: string;
    fullWidth?: boolean;
}

const { src, fullWidth = true } = Astro.props;
const uniqueId = "pdf-" + Math.random().toString(36).substr(2, 9);
---

<div
    class:list={["pdf-viewer-wrapper", { "pdf-full-width": fullWidth }]}
    id={`wrapper-${uniqueId}`}
>
    <div class="pdf-container">
        <!-- Pages Container -->
        <div id={`pdf-pages-${uniqueId}`} class="pdf-pages"></div>

        <!-- Controls Overlay -->
        <div class="pdf-controls">
            <button
                id={`pdf-prev-${uniqueId}`}
                class="nav-btn"
                aria-label="Previous page"
            >
                <span class="nav-btn-inner">←</span>
            </button>
            <div id={`pdf-page-indicator-${uniqueId}`} class="page-indicator">
                1 / 1
            </div>
            <button
                id={`pdf-next-${uniqueId}`}
                class="nav-btn"
                aria-label="Next page"
            >
                <span class="nav-btn-inner">→</span>
            </button>
        </div>

        <!-- Click Overlay (Invisible) -->
        <div id={`pdf-click-area-${uniqueId}`} class="click-area"></div>

        <!-- First Page Click Icon -->
        <img
            id={`pdf-click-icon-${uniqueId}`}
            src="/assets/logos/click.png"
            class="click-icon"
            alt="Click to navigate"
        />
    </div>
</div>

<script define:vars={{ src, uniqueId }}>
    async function initPDF() {
        if (!window.pdfjsLib) {
            const script = document.createElement("script");
            script.src =
                "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js";
            document.head.appendChild(script);
            await new Promise((resolve) => {
                script.onload = resolve;
            });
            window.pdfjsLib = window["pdfjs-dist/build/pdf"];
            window.pdfjsLib.GlobalWorkerOptions.workerSrc =
                "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
        }

        const pagesContainer = document.getElementById(`pdf-pages-${uniqueId}`);
        const prevBtn = document.getElementById(`pdf-prev-${uniqueId}`);
        const nextBtn = document.getElementById(`pdf-next-${uniqueId}`);
        const pageIndicator = document.getElementById(
            `pdf-page-indicator-${uniqueId}`,
        );
        const clickArea = document.getElementById(`pdf-click-area-${uniqueId}`);
        const clickIcon = document.getElementById(`pdf-click-icon-${uniqueId}`);
        const wrapper = document.getElementById(`wrapper-${uniqueId}`);
        const container = wrapper.querySelector(".pdf-container");

        let pdfDoc = null;
        let pageNum = 1;
        let totalPages = 0;
        let isRendered = false;
        let isVisible = false;
        let isPaused = window.pdfAutoplayPaused || false;
        let isHovered = false;
        let autoplayInterval = null;

        async function renderAllPages() {
            if (!pdfDoc) return;
            isRendered = true;

            // Clear existing
            pagesContainer.innerHTML = "";

            // Get container dimensions - use offsetHeight since padding-top creates the height
            const containerWidth = container.offsetWidth;
            const containerHeight = container.offsetHeight;

            // Render visible page first for speed
            await renderPageToCanvas(pageNum, containerWidth, containerHeight);

            // Render rest in background
            for (let i = 1; i <= totalPages; i++) {
                if (i !== pageNum) {
                    renderPageToCanvas(i, containerWidth);
                }
            }
        }

        async function renderPageToCanvas(num, cWidth) {
            const page = await pdfDoc.getPage(num);
            const viewport = page.getViewport({ scale: 1 });

            // Calculate visual scale to fit container width
            const visualScale = cWidth / viewport.width;

            // Get device pixel ratio for high-DPI rendering
            const dpr = window.devicePixelRatio || 1;

            // Render at higher resolution based on dpr
            const renderViewport = page.getViewport({
                scale: visualScale * dpr,
            });

            const canvas = document.createElement("canvas");
            canvas.className = `pdf-page page-${num}`;

            // Set actual canvas size (high-res)
            canvas.height = renderViewport.height;
            canvas.width = renderViewport.width;

            // Fix for high-DPI: Constrain display size to container instructions
            canvas.style.width = "100%";
            canvas.style.height = "auto";

            // Initial visibility state
            canvas.style.display = num === pageNum ? "block" : "none";

            pagesContainer.appendChild(canvas);

            const ctx = canvas.getContext("2d");
            await page.render({
                canvasContext: ctx,
                viewport: renderViewport,
            }).promise;
        }

        function updateView() {
            // Toggle visibility of pre-rendered canvases
            const canvases = pagesContainer.querySelectorAll("canvas");
            canvases.forEach((canvas) => {
                if (canvas.classList.contains(`page-${pageNum}`)) {
                    canvas.style.display = "block";
                    // Natural flow handles height
                } else {
                    canvas.style.display = "none";
                }
            });

            // Update page indicator
            if (totalPages > 1) {
                pageIndicator.textContent = `${pageNum} / ${totalPages}`;
            } else {
                pageIndicator.style.display = "none";
            }

            // Update nav buttons state
            prevBtn.disabled = pageNum <= 1;
            nextBtn.disabled = pageNum >= totalPages;
            prevBtn.style.opacity = pageNum <= 1 ? "0.5" : "1";
            nextBtn.style.opacity = pageNum >= totalPages ? "0.5" : "1";

            // Click Icon Visibility (Only on Page 1)
            if (clickIcon) {
                clickIcon.style.opacity = pageNum === 1 ? "1" : "0";
                clickIcon.style.pointerEvents = pageNum === 1 ? "auto" : "none"; // Make clickable only on page 1
            }
        }

        function changePage(delta, allowLoop = false) {
            let newPage = pageNum + delta;
            if (allowLoop) {
                if (newPage > totalPages) newPage = 1;
                if (newPage < 1) newPage = totalPages;
            }
            if (newPage >= 1 && newPage <= totalPages) {
                pageNum = newPage;
                updateView();
            }
        }

        prevBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            changePage(-1, true);
        });

        nextBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            changePage(1, true);
        });

        // Keyboard Interaction
        window.addEventListener("keydown", (e) => {
            if (!isVisible) return;

            // Don't trigger if user is typing in an input
            if (["INPUT", "TEXTAREA"].includes(document.activeElement?.tagName))
                return;

            if (e.key === "ArrowRight") {
                changePage(1, true);
            } else if (e.key === "ArrowLeft") {
                changePage(-1, true);
            }
        });

        clickArea.addEventListener("click", (e) => {
            const rect = clickArea.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const halfWidth = rect.width / 2;

            if (clickX < halfWidth) {
                // Left side - go to previous
                changePage(-1, true);
            } else {
                // Right side - go to next
                changePage(1, true);
            }
        });

        // Click Icon interaction
        if (clickIcon) {
            clickIcon.addEventListener("click", (e) => {
                e.stopPropagation();
                changePage(1, true); // Go to next page
            });
        }

        // Re-render on resize (debounced)
        let resizeTimeout;
        window.addEventListener("resize", () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (pdfDoc) renderAllPages();
            }, 200);
        });

        try {
            pdfDoc = await window.pdfjsLib.getDocument(src).promise;
            totalPages = pdfDoc.numPages;
            pageIndicator.textContent = `1 / ${totalPages}`;

            // Get first page done, but rely on renderAllPages to draw
            // const firstPage = await pdfDoc.getPage(1);
            // const viewport = firstPage.getViewport({ scale: 1 });
            // const aspectRatio = (viewport.height / viewport.width) * 100;
            // container.style.paddingTop = aspectRatio + "%";

            await renderAllPages();
            updateView();

            // Visibility-based autoplay: only advance when 40% of viewer is visible

            wrapper.addEventListener("mouseenter", () => {
                isHovered = true;
                stopAutoplay();
            });

            wrapper.addEventListener("mouseleave", () => {
                isHovered = false;
                if (isVisible && !isPaused) {
                    startAutoplay();
                }
            });

            function startAutoplay() {
                if (
                    autoplayInterval ||
                    totalPages <= 1 ||
                    isPaused ||
                    isHovered
                )
                    return;
                autoplayInterval = setInterval(() => {
                    if (pageNum >= totalPages) {
                        pageNum = 1;
                    } else {
                        pageNum++;
                    }
                    updateView();
                }, 1500);
            }

            function stopAutoplay() {
                if (autoplayInterval) {
                    clearInterval(autoplayInterval);
                    autoplayInterval = null;
                }
            }

            // Listen for global pause/resume events
            window.addEventListener("pdfAutoplayToggle", (e) => {
                isPaused = e.detail.paused;
                if (isPaused) {
                    stopAutoplay();
                } else if (isVisible && !isHovered) {
                    startAutoplay();
                }
            });

            const observer = new IntersectionObserver(
                (entries) => {
                    entries.forEach((entry) => {
                        isVisible = entry.isIntersecting;
                        if (isVisible && !isPaused) {
                            startAutoplay();
                        } else {
                            stopAutoplay();
                        }
                    });
                },
                { threshold: 0.4 },
            );

            observer.observe(wrapper);
        } catch (error) {
            console.error("Error loading PDF:", error);
            pageIndicator.textContent = "Error";
        }
    }

    // Initialize immediately if DOM is ready, or wait
    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initPDF);
    } else {
        initPDF();
    }
</script>

<style>
    .pdf-viewer-wrapper {
        width: 100%;
        margin-top: 6rem;
        margin-bottom: 0.5rem;
    }

    .pdf-viewer-wrapper.pdf-full-width {
        /* Break out of parent padding (4rem = 64px on desktop) */
        width: calc(100% + 8rem);
        margin-left: -4rem;
        margin-right: -4rem;
        transform: none;
    }

    @media (max-width: 1024px) {
        .pdf-viewer-wrapper.pdf-full-width {
            /* Break out of parent padding (20px on mobile) */
            width: calc(100% + 40px);
            margin-left: -20px;
            margin-right: -20px;
        }
    }

    .pdf-viewer-wrapper.pdf-full-width .pdf-container {
        max-width: 1400px;
        margin: 0 auto;
    }

    .pdf-container {
        width: 100%;
        position: relative;
        background: var(--surface-secondary, #f5f5f5);
        border-radius: var(--radius-md, 8px);
        overflow: hidden;
        /* Min-height to prevent collapse during load */
        min-height: 200px;
    }

    .pdf-pages {
        position: relative;
        width: 100%;
        height: auto;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1;
    }

    .pdf-pages :global(canvas) {
        width: 100% !important;
        height: auto !important;
        display: block;
    }

    .pdf-pages :global(.pdf-page) {
        max-width: 100%;
        max-height: 100%;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        border-radius: 4px;
    }

    .pause-btn {
        position: absolute;
        top: 0.75rem;
        right: 0.75rem;
        width: 28px;
        height: 28px;
        background: var(--bg-secondary, rgba(30, 30, 30, 0.8));
        backdrop-filter: blur(8px);
        border: 1px solid var(--border-subtle, rgba(255, 255, 255, 0.1));
        border-radius: var(--radius-sm, 4px);
        color: rgba(255, 255, 255, 0.9);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
        transition: all 0.2s ease;
    }

    .pause-btn:hover {
        background: var(--accent-secondary, #42bd49);
        border-color: var(--accent-secondary, #42bd49);
    }

    .pause-icon {
        font-size: 0.6rem;
        line-height: 1;
    }

    .click-area {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 5;
        cursor: pointer;
    }

    /* Bottom Controls */
    .pdf-controls {
        position: absolute;
        bottom: 1rem;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        align-items: center;
        gap: 8px;
        background: var(--bg-secondary, rgba(30, 30, 30, 0.8));
        backdrop-filter: blur(8px);
        padding: 4px;
        border-radius: var(--radius-md, 8px);
        z-index: 10;
        border: 1px solid var(--border-subtle, rgba(255, 255, 255, 0.1));
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .page-indicator {
        color: rgba(255, 255, 255, 0.9);
        font-size: 0.75rem;
        font-family: "Space Mono", monospace;
        min-width: 30px;
        text-align: center;
        pointer-events: none;
        line-height: 1;
    }
    .nav-btn {
        background: transparent;
        border: none;
        color: var(--text-primary, white);
        width: 21px;
        height: 21px;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .nav-btn-inner {
        width: 21px;
        height: 21px;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 1px solid var(--border-subtle, rgba(255, 255, 255, 0.2));
        border-radius: var(--radius-sm, 4px);
        font-size: 0.7rem;
        line-height: 1;
        transition: all 0.2s ease;
    }

    .nav-btn:hover:not(:disabled) .nav-btn-inner {
        background: var(--accent-secondary, #42bd49);
        border-color: var(--accent-secondary, #42bd49);
        color: white;
    }

    .nav-btn:disabled {
        cursor: not-allowed;
    }

    :global([data-theme="dark"]) .pdf-container {
        background: rgba(255, 255, 255, 0.03);
    }

    :global([data-theme="dark"] .pdf-page) {
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .click-icon {
        position: absolute;
        bottom: 1rem;
        right: 2rem;
        width: 60px !important; /* Override ProjectSection global img styles */
        height: auto !important;
        margin: 0 !important;
        max-width: none !important;
        display: block;
        opacity: 0;
        transition: opacity 0.3s ease;
        z-index: 20;
        pointer-events: none; /* Changed via JS */
        cursor: pointer;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
    }

    @media (max-width: 768px) {
        .click-icon {
            width: 24px !important;
            right: 0.5rem;
            bottom: 0.5rem;
        }
    }
</style>
